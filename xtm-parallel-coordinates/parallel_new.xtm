
;;; parallel_coordinates.xtm:merged code and example --

;; Author: noiach
;; Keywords: extempore
;; Required dylibs: libglfw3, libnanovg

;;; Commentary:

;;

;;; Code:
;;(sys:load "libs/external/system.xtm")


;; setup GLFW3 and nanovg
(sys:load "libs/external/glfw3.xtm")
(bind-val width  i32 1800)
(bind-val height i32 1000)
(bind-val window GLFWwindow*
  (glfw_init_and_create_interaction_window (convert width) (convert height)))
(sys:load "libs/external/nanovg.xtm")
(bind-val vg NVGcontext* (nvg_create_context))
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))

(call-as-xtlang
 (nvgCreateFont vg "default" "/Library/Fonts/Arial.ttf")
 (nvgFontFace vg "default"))

(bind-func set_bg
   (lambda (vg:NVGcontext*)
     (_nvgFillColor vg (NVGcolor 0.0 0.0 0.0 1.0))
     (nvgBeginPath vg)
     (nvgRect vg 0. 0. (convert width) (convert height))
     (nvgFill vg)))
;(dv_draw_axis_labels_2D.font_size 18)

;;(sys:load "libs/core/math_ext.xtm")

(sys:load "csv.xtm")
(sys:load "datavis-lib.xtm")
(sys:load "clustering-kmeans.xtm")

;;(set! current_line:float* (zalloc (+ (* (- n 1) 2) (* 2 n))))

(bind-type Dataset <Data*,Clusters,Centroids>)

(bind-func load_dataset
  (lambda (filename:i8* k:i64)
    (let ((data (load_csv filename))
          (both (cluster-kmeans data k))
          (clusters (tref both 0))
          (centroids (tref both 1)))
          (Dataset_h data clusters centroids))))

(bind-func load_dataset
  (lambda (filename:i8* centroids-old:Centroids k:i64)
    (let ((data (load_csv filename))
          (both (cluster-kmeans data centroids-old k))
          (clusters (tref both 0))
          (centroids (tref both 1)))
          (Dataset_h data clusters centroids))))


(bind-val data-count i64)
(bind-val csv_list List{i8*}*)
(bind-val all_datasets Dataset**)
(bind-val global-range Range**)
(bind-func set-global-range
  (lambda ()
    ;(set! global-range (halloc d))
    (let ((i 0)
          (j 0)
          (d (tref (tref (pref all_datasets 0) 0 ) 3))
          (global:Range** (halloc d))
          )
      (dotimes (i d)
        (let ((range (Range 10000000000.0 -10000000000.0)))
        (dotimes (j data-count)
          (tset! range 0 (min (tref range 0) (tref (tref (pref (tref (tref (pref all_datasets j) 0) 2) i) 3) 0)))
          (tset! range 1 (max (tref range 1) (tref (tref (pref (tref (tref (pref all_datasets j) 0) 2) i) 3) 1)))
        )
        (pset! global i range)
        ))
    (set! global-range global))))
(bind-func set-data
  (lambda (csvs)
    (set! csv_list csvs)
    (set! data-count (length csv_list))


    (let ((i:i64 1)
          (datasets:Dataset** (halloc data-count))
          (k:i64 3))
    (pset! datasets 0 (load_dataset (nth csv_list 0) k))
      (dotimes (i 1 (- data-count 1))
          (pset! datasets i (load_dataset (nth csv_list i) (tref (pref datasets (- i 1)) 2) k))
        )
      (set! all_datasets datasets)
    (set-global-range)
    )))


;($ (println (tref (pref global-range1 55) 0)))

(bind-val alpha float)
(bind-val colors NVGcolor** 4)
(bind-func set-colors
  (lambda ()
    ;(set! colors (halloc 4))
    (set! alpha (convert 0.4 float))
    (pset! colors 2 (NVGcolor 0.94 0.72 0.24 alpha))
    (pset! colors 1 (NVGcolor 0.00 0.60 0.54 alpha))
    (pset! colors 0 (NVGcolor 0.83 0.07 0.22 alpha))
    (pset! colors 3 (NVGcolor 1.00 0.46 0.43 alpha))
    ))
(set-colors)

;($ (nvg_loop))

(bind-func intermediate:[float,float,float,double]*
  (lambda (old goal transition)
    (+ (* (convert transition) goal ) (* (convert (- 1.0 transition )) old ))
    ))

(bind-func intermediate:[double,double,double,double]*
  (lambda (old goal transition)
    (+ (* (convert transition) goal ) (* (convert (- 1.0 transition )) old ))
    ))



(bind-func pc_no_centroids
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (z:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current-old:double 0.0)
        (current-goal:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (cluster-goal:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (n:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (clusters-goal:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        (data-goal:Data* null)
        (vectors-goal:double* null)
        (centroids-goal:Centroids null)
        (color:NVGcolor* null)
        (color-goal:NVGcolor* null)
        )
    (lambda (bounds:Rect* dataset:Dataset* dataset-goal:Dataset* transition:double tr1:bool tr2:bool tr3:bool tr4:bool)
      (set! data (tref dataset 0))
      (set! data-goal (tref dataset-goal 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! vectors-goal (tuple-ref data-goal 0))
      (set! clusters-goal (tuple-ref dataset-goal 1))
      (set! centroids-goal (tuple-ref dataset-goal 2))
      (set! axes (tuple-ref data 2))
      (set! n (tuple-ref data 1))
      (set! d (tuple-ref data 3))
      (let ((current_line:float* (halloc (+ (* (- n 1) 2) (* 2 n)))))
      (dotimes (i n)
        (set! cluster (pref clusters i))
        (set! cluster-goal (pref clusters-goal i))

        (dotimes (j d)
              (set! axis (pref axes j))
              (set! offset (tuple-ref axis 1))
              ;(set! range (tuple-ref axis 3))
              (set! range (pref global-range j))
              (set! minv (tuple-ref range 0))
              (set! maxv (tuple-ref range 1))

              (set! current (pref vectors (+ j (* i d))))
              (if (= tr1 1)
                (dotimes (z 1)
                  (set! current-goal (pref vectors-goal (+ j (* i d))))
                  (set! current (+ (* transition current-goal ) (* (- 1.0 transition ) current )))
              ))
              (if (or (= tr3 1) (= tr4 1))
                (set! current (pref vectors-goal (+ j (* i d))))
              )

              (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
              (pset! current_line (* j 2) (convert (offset)) )
              (pset! current_line (+ (* j 2) 1) (convert normalized) )
              )
        (set! color (pref colors cluster))
        (if (= tr4 1)
          (dotimes (z 1)
            (set! color-goal (pref colors cluster-goal))
            (set! color (NVGcolor (intermediate (tref color 0) (tref color-goal 0) transition)
                                  (intermediate (tref color 1) (tref color-goal 1) transition)
                                  (intermediate (tref color 2) (tref color-goal 2) transition)
                                  alpha))
        ))
        (dv_draw_line_curve_no_centroids vg bounds current_line d color))
        (dotimes (i d)
          (dv_draw_axis_2D vg bounds (pref axes i) (pref global-range i)))
        #t
    ))))




(bind-func pc_animation
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (z:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current-old:double 0.0)
        (current-goal:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (cluster-goal:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (n:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (clusters-goal:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        (data-goal:Data* null)
        (vectors-goal:double* null)
        (centroids-goal:Centroids null)
        (color:NVGcolor* null)
        (color-goal:NVGcolor* null)
        )
    (lambda (bounds:Rect* dataset:Dataset* dataset-goal:Dataset* transition:double tr1:bool tr2:bool tr3:bool tr4:bool)
      (set! data (tref dataset 0))
      (set! data-goal (tref dataset-goal 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! vectors-goal (tuple-ref data-goal 0))
      (set! clusters-goal (tuple-ref dataset-goal 1))
      (set! centroids-goal (tuple-ref dataset-goal 2))
      (set! axes (tuple-ref data 2))
      (set! n (tuple-ref data 1))
      (set! d (tuple-ref data 3))
      (let ((current_line:float* (halloc (+ (* (- d 0) 2) (* 2 d)))))

      (dotimes (i n)
        (set! cluster (pref clusters i))
        (set! cluster-goal (pref clusters-goal i))

        (dotimes (j d)
              (set! axis (pref axes j))
              (set! offset (tuple-ref axis 1))
              ;(set! range (tuple-ref axis 3))
              (set! range (pref global-range j))
              (set! minv (tuple-ref range 0))
              (set! maxv (tuple-ref range 1))

              (set! current (pref vectors (+ j (* i d))))
              (if (= tr1 1)
                (dotimes (z 1)
                  (set! current-goal (pref vectors-goal (+ j (* i d))))
                  (set! current (+ (* transition current-goal ) (* (- 1.0 transition ) current )))
              ))
              (if (or (= tr3 1) (= tr4 1))
                (set! current (pref vectors-goal (+ j (* i d))))
              )

              (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
              (pset! current_line (* j 2) (convert (offset)) )
              (pset! current_line (+ (* j 2) 1) (convert normalized) )
              )
        (set! color (pref colors 1))
        (if (= tr4 1)
          (dotimes (z 1)
            (set! color-goal (pref colors cluster-goal))
            (set! color (NVGcolor (intermediate (tref color 0) (tref color-goal 0) transition)
                                  (intermediate (tref color 1) (tref color-goal 1) transition)
                                  (intermediate (tref color 2) (tref color-goal 2) transition)
                                  alpha))
        ))
        (dv_draw_line_curve_no_centroids vg bounds current_line d color))

        (dotimes (i d)
          (dv_draw_axis_2D vg bounds (pref axes i) (pref global-range i)))
        #t
    ))))


(bind-func pc_transition_data2
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (z:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (range2:Range* null)
        (minv2:double 0.0)
        (maxv2:double 0.0)
        (current:double 0.0)
        (current-old:double 0.0)
        (current-goal:double 0.0)
        (current2:double 0.0)
        (current-real:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (cluster-goal:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (n:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (clusters-goal:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        (data-goal:Data* null)
        (vectors-goal:double* null)
        (centroids-goal:Centroids null)
        (color:NVGcolor* null)
        (color-goal:NVGcolor* null)
        )
    (lambda (bounds:Rect* dataset:Dataset* dataset-goal:Dataset* transition:double tr1:bool tr2:bool tr3:bool tr4:bool)
      (set! data (tref dataset 0))
      (set! data-goal (tref dataset-goal 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! vectors-goal (tuple-ref data-goal 0))
      (set! clusters-goal (tuple-ref dataset-goal 1))
      (set! centroids-goal (tuple-ref dataset-goal 2))
      (set! axes (tuple-ref data 2))
      (set! n (tuple-ref data 1))
      (set! d (tuple-ref data 3))
      (let ((current_line:float* (halloc (+ (* (- d 0) 2) (* 2 d)))))
      (dotimes (i n)
        (set! cluster (pref clusters i))
        (set! cluster-goal (pref clusters-goal i))

        (dotimes (j d)
              (set! axis (pref axes j))
              (set! offset (tuple-ref axis 1))
              ;(set! range (tuple-ref axis 3))
              (set! range (pref global-range j))
              (set! minv (tuple-ref range 0))
              (set! maxv (tuple-ref range 1))

              (set! current (pref vectors (+ j (* i d))))
              (if (= tr1 1)
                (dotimes (z 1)
                  (set! current-goal (pref vectors-goal (+ j (* i d))))
                  (set! current (+ (* transition current-goal ) (* (- 1.0 transition ) current )))
              ))
              (if (or (= tr3 1) (= tr4 1))
                (set! current (pref vectors-goal (+ j (* i d))))
              )

              (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
              (pset! current_line (* j 4) (convert (offset)) )
              (pset! current_line (+ (* j 4) 1) (convert normalized) )

              (if (< j (- d 1))
                (let ((a #t))
                  (set! offset2 (tuple-ref (pref axes (+ j 1)) 1))
                  (set! range2 (pref global-range (+ j 1)))
                  (set! minv2 (tuple-ref range2 0))
                  (set! maxv2 (tuple-ref range2 1))

                  (set! current-old (pref vectors (+ (+ j 1) (* i d))))
                  (set! current-old (* 0.99 (+ minv (* (- maxv minv) (/ (- current-old minv2) (- maxv2 minv2))  )   )))
                  (set! current2 (intermediate current current-old 0.5))
                  (if (= tr4 #t)
                    (set! current2 (pref centroids-goal (+ j (* cluster-goal d)) ))
                  )
                  (if (= tr2 #t)
                    (dotimes (z 1)
                      ;(set! current2 (pref centroids (+ j (* cluster d)) ))
                      (set! current-goal (pref centroids-goal (+ j (* cluster d)) ))
                      (set! current2 (+ (* transition current-goal ) (* (- 1.0 transition ) current2 )))
                  ))
                  (if (= tr3 #t)
                    (dotimes (z 1)
                    (set! current-old (pref centroids-goal (+ j (* cluster d)) ))
                    (set! current-goal (pref centroids-goal (+ j (* cluster-goal d)) ))
                    (set! current2 (+ (* transition current-goal ) (* (- 1.0 transition ) current-old )))
                  ))
                  (set! current-real (pref centroids (+ j (* cluster d)) )    )
                  (if (= current-real 0.0)
                    (set! normalized 0.0)
                    (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current2 minv) (- maxv minv)))))
                  )
                  (if (= current-real 0.0)
                    (set! spacingn 0.0)
                    (set! spacingn (* 0.1 (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- (- current current2 ) minv) (- maxv minv))))))
                  )
                  (pset! current_line (+ (* j 4) 2) (convert (/ (+ offset offset2) (convert 2))) )
                  (pset! current_line (+ (* j 4) 3) (convert (+ spacingn normalized)) )
                )))
        (set! color (pref colors cluster))
        (if (= tr4 1)
          (dotimes (z 1)
            (set! color-goal (pref colors cluster-goal))
            (set! color (NVGcolor (intermediate (tref color 0) (tref color-goal 0) transition)
                                  (intermediate (tref color 1) (tref color-goal 1) transition)
                                  (intermediate (tref color 2) (tref color-goal 2) transition)
                                  alpha))
        ))
        (dv_draw_line_curve vg bounds current_line d color))
        (dotimes (i d)
          (dv_draw_axis_2D vg bounds (pref axes i) range))
        #t
    ))))



(bind-func pc_transition_data
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (z:i64 0)
        (axis:Axis* null)
        (offset:float (convert 0))
        (offset2:float (convert 0))
        (range:Range* null)
        (minv:double 0.0)
        (maxv:double 0.0)
        (current:double 0.0)
        (current-old:double 0.0)
        (current-goal:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (cluster-goal:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (n:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (clusters-goal:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        (data-goal:Data* null)
        (vectors-goal:double* null)
        (centroids-goal:Centroids null)
        (color:NVGcolor* null)
        (color-goal:NVGcolor* null)
        )
    (lambda (bounds:Rect* dataset:Dataset* dataset-goal:Dataset* transition:double tr1:bool tr2:bool tr3:bool tr4:bool)
      (set! data (tref dataset 0))
      (set! data-goal (tref dataset-goal 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! vectors-goal (tuple-ref data-goal 0))
      (set! clusters-goal (tuple-ref dataset-goal 1))
      (set! centroids-goal (tuple-ref dataset-goal 2))
      (set! axes (tuple-ref data 2))
      (set! n (tuple-ref data 1))
      (set! d (tuple-ref data 3))
      (let ((current_line:float* (halloc (+ (* (- d 0) 2) (* 2 d)))))
      (dotimes (i n)
        (set! cluster (pref clusters i))
        (set! cluster-goal (pref clusters-goal i))

        (dotimes (j d)
              (set! axis (pref axes j))
              (set! offset (tuple-ref axis 1))
              ;(set! range (tuple-ref axis 3))
              (set! range (pref global-range j))
              (set! minv (tuple-ref range 0))
              (set! maxv (tuple-ref range 1))

              (set! current (pref vectors (+ j (* i d))))
              (if (= tr1 1)
                (dotimes (z 1)
                  (set! current-goal (pref vectors-goal (+ j (* i d))))
                  (set! current (+ (* transition current-goal ) (* (- 1.0 transition ) current )))
              ))
              (if (or (= tr3 1) (= tr4 1))
                (set! current (pref vectors-goal (+ j (* i d))))
              )

              (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current minv) (- maxv minv)))))
              (pset! current_line (* j 4) (convert (offset)) )
              (pset! current_line (+ (* j 4) 1) (convert normalized) )

              (if (< j (- d 1))
                (let ((a #t))
                  (set! offset2 (tuple-ref (pref axes (+ j 1)) 1))
                  (set! current2 (pref centroids (+ j (* cluster d)) ))
                  (if (= tr4 #t)
                    (set! current2 (pref centroids-goal (+ j (* cluster-goal d)) ))
                  )
                  (if (= tr2 #t)
                    (dotimes (z 1)
                      (set! current2 (pref centroids (+ j (* cluster d)) ))
                      (set! current-goal (pref centroids-goal (+ j (* cluster d)) ))
                      (set! current2 (+ (* transition current-goal ) (* (- 1.0 transition ) current2 )))
                  ))
                  (if (= tr3 #t)
                    (dotimes (z 1)
                    (set! current-old (pref centroids-goal (+ j (* cluster d)) ))
                    (set! current-goal (pref centroids-goal (+ j (* cluster-goal d)) ))
                    (set! current2 (+ (* transition current-goal ) (* (- 1.0 transition ) current-old )))
                  ))
                  (if (= current2 0.0)
                    (set! normalized 0.0)
                    (set! normalized (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current2 minv) (- maxv minv)))))
                  )
                  (if (= current2 0.0)
                    (set! spacingn 0.0)
                    (set! spacingn (* 0.1 (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- (- current current2 ) minv) (- maxv minv))))))
                  )
                  (pset! current_line (+ (* j 4) 2) (convert (/ (+ offset offset2) (convert 2))) )
                  (pset! current_line (+ (* j 4) 3) (convert (+ spacingn normalized)) )
                )))
        (set! color (pref colors cluster))
        (if (= tr4 1)
          (dotimes (z 1)
            (set! color-goal (pref colors cluster-goal))
            (set! color (NVGcolor (intermediate (tref color 0) (tref color-goal 0) transition)
                                  (intermediate (tref color 1) (tref color-goal 1) transition)
                                  (intermediate (tref color 2) (tref color-goal 2) transition)
                                  alpha))
        ))
        (dv_draw_line_curve vg bounds current_line d color))
        (dotimes (i d)
          (dv_draw_axis_2D vg bounds (pref axes i) range))
        #t
    ))))




(bind-func sp_transition_data
  (let (
        (i:i64 0)
        (j:i64 0)
        (k:i64 0)
        (z:i64 0)
        (axis1:Axis* null)
        (axis2:Axis* null)
        (range1:Range* null)
        (minv1:double 0.0)
        (maxv1:double 0.0)
        (range2:Range* null)
        (minv2:double 0.0)
        (maxv2:double 0.0)
        (current:double 0.0)
        (current1-goal:double 0.0)
        (current2-goal:double 0.0)
        (current1:double 0.0)
        (current2:double 0.0)
        (normalized:double 0.0)
        (normalized2:double 0.0)
        (spacing:double 0.0)
        (spacingn:double 0.0)
        (cluster:i64 0)
        (cluster-goal:i64 0)
        (crange:Range* null)
        (minr:double 0.0)
        (maxr:double 0.0)
        (padding 0.1)
        (vectors:double* null)
        (axes:Axis** null)
        (d:i64 0)
        (n:i64 0)
        (both:BothCCR* null)
        (clusters:Clusters null)
        (clusters-goal:Clusters null)
        (centroids:Centroids null)
        (data:Data* null)
        (data-goal:Data* null)
        (vectors-goal:double* null)
        (centroids-goal:Centroids null)
        (color:NVGcolor* null)
        (color-goal:NVGcolor* null)
        (newalpha:float 1.0)
        )
    (lambda (bounds:Rect* dataset:Dataset* dataset-goal:Dataset* d1:i64 d2:i64 transition:double tr1:bool tr2:bool)
      (set! data (tref dataset 0))
      (set! data-goal (tref dataset-goal 0))
      (set! clusters (tuple-ref dataset 1))
      (set! centroids (tuple-ref dataset 2))
      (set! vectors (tuple-ref data 0))
      (set! vectors-goal (tuple-ref data-goal 0))
      (set! clusters-goal (tuple-ref dataset-goal 1))
      (set! centroids-goal (tuple-ref dataset-goal 2))
      (set! axes (tuple-ref data 2))
      (set! n (tuple-ref data 1))
      (set! d (tuple-ref data 3))
      (let ((current_line:float* (halloc (* n 2))))
      (set! axis1 (pref axes d1))
      (set! range1 (pref global-range d1))
      (set! minv1 (tuple-ref range1 0))
      (set! maxv1 (tuple-ref range1 1))
      (set! axis2 (pref axes d2))
      (set! range2 (pref global-range d2))
      (set! minv2 (tuple-ref range2 0))
      (set! maxv2 (tuple-ref range2 1))

      (dotimes (i n)
        (set! cluster (pref clusters i))
        (set! cluster-goal (pref clusters-goal i))

        (set! current1 (pref vectors (+ d1 (* i d))))
        (set! current1-goal (pref vectors-goal (+ d1 (* i d))))
        (if (= tr1 1)
          (set! current1 (+ (* transition current1-goal ) (* (- 1.0 transition ) current1 ))))
        (if (= tr2 1)
          (set! current1 current1-goal))
        (set! current2 (pref vectors (+ d2 (* i d))))
        (set! current2-goal (pref vectors-goal (+ d2 (* i d))))
        (if (= tr1 1)
          (set! current2 (+ (* transition current2-goal ) (* (- 1.0 transition ) current2 ))))
        (if (= tr2 1)
          (set! current2 current2-goal))
        (set! normalized  (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current1 minv1) (- maxv1 minv1)))))
        (set! normalized2 (+ padding (* (- 1.0 (* 2.0 padding)) (/ (- current2 minv2) (- maxv2 minv2)))))
        (set! color (pref colors cluster))
        (set! color (NVGcolor (tref color 0) (tref color 1) (tref color 2) newalpha))
        (if (= tr2 1)
          (dotimes (z 1)
            (set! color-goal (pref colors cluster-goal))
            (set! color (NVGcolor (intermediate (tref color 0) (tref color-goal 0) transition)
                                  (intermediate (tref color 1) (tref color-goal 1) transition)
                                  (intermediate (tref color 2) (tref color-goal 2) transition)
                                  newalpha))
        ))
        (dv_draw_scatter_point vg bounds (convert normalized) (convert normalized2) color)
        )
      (dv_draw_axes_2D vg bounds)
      (dv_draw_axis_labels_2D vg bounds axis1 axis2 range1 range2)
        ;(dv_draw_scatter_points vg bounds current_line n 2.0)
      #t
    ))))







(bind-func transform_data
  (lambda (data:Data*)
    data
    ))
